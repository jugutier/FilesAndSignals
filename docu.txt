En las clases teóricas les expliqué lo siguiente:

1. La función signal() atrapa una señal una sola vez, si debe quedar atrapada permanentemente hay que volver a hacer signal() dentro del manejador para atraparla nuevamente.

2. Los system calls bloqueantes (cono read) se interrumpen cuando se recibe una señal atrapada. En ese caso retornan -1 y el código de error (errno) es EINTR, que la función perror() imprime como "Interrupted system call" o un mensaje equivalente en castellano dependiendo del locale que tenga su sistema.

Esto es cierto en el Unix tradicional y en todas las variantes que conforman con la norma Posix. En el caso particular de Linux, esto no se cumple por defecto. Normalmente signal() atrapa las señales indefinidamente y muchos system calls bloqueantes no retornan cuando llega una señal atrapada. Este comportamiento ha sido tomado del Unix de BSD. Probablemente sea mejor que el de Posix, pero no es standard.

Para que Linux se comporte como lo indica Posix, debe definirse el macro _POSIX_SOURCE. Les acompaño un pequeño programa de prueba:

//#define _POSIX_SOURCE

#include <stdio.h>
#include <signal.h>

void dummy(int n) { puts("SIGINT"); }

main()
{
	int n;
	char buf[100];

	signal(SIGINT, dummy);
	printf("%d\n", n = read(0, buf, sizeof buf));
	if ( n == -1 )
		perror("read");
	printf("%d\n", n = read(0, buf, sizeof buf));
	if ( n == -1 )
		perror("read");

	return 0;
}

Compílenlo tal como está, ejecútenlo y tipeen control-C varias veces. Van a ver que la señal permanece atrapada y read() no retorna. Entren una línea para que retorne el primer read(). Repitan. El proceso termina cuando ingresan la segunda línea. Esta es la salida:

hugo@hugo-desktop:~$ ./p
^CSIGINT
^CSIGINT
aaa
4
^CSIGINT
^CSIGINT
^CSIGINT
^CSIGINT
bbbbbbbbb
10
hugo@hugo-desktop:~$ 

Ahora descomenten el macro y compilen de nuevo. El comportamiento cambia, la primera señal hace que el primer read() retorne y la segunda liquida el proceso. Esto es lo que indica Posix.

hugo@hugo-desktop:~$ ./p
^CSIGINT
-1
read: Interrupted system call
^C
hugo@hugo-desktop:~$ 

Aquí les paso un par de implementaciones mías (prácticamente copiadas de las originales de Stevens) de las funciones readn() y writen() que hemos visto con varios de ustedes. Sirven especialmente para pipes y sockets, donde read() y write() pueden leer/escribir menos bytes que los que se solicitan. Son más eficientes que las implementaciones que leen y escriben byte por byte.


#include <errno.h>
#include <unistd.h>

ssize_t
readn(int fd, void *vptr, size_t n)
{
	size_t nleft;
	ssize_t nread;
	char *ptr;

	for ( ptr = vptr, nleft = n ; nleft > 0 ; nleft -= nread, ptr += nread )
		if ( (nread = read(fd, ptr, nleft)) < 0 )
		{
			if ( errno == EINTR )
				nread = 0;
			else
				return -1;
		}
		else if ( nread == 0 )
			break;
	return n - nleft;			/* 0 <= result <= n */
}

ssize_t	
writen(int fd, const void *vptr, size_t n)
{
	size_t nleft;
	ssize_t nwritten;
	const char *ptr;

	for ( ptr = vptr, nleft = n ; nleft > 0 ; nleft -= nwritten, ptr += nwritten )
		if ( (nwritten = write(fd, ptr, nleft)) < 0 )
		{
			if ( errno == EINTR )
				nwritten = 0;
			else
				return -1;
		}
		else if ( nwritten == 0 )
			break;
	return n - nleft;			/* 0 <= result <= n */
}

Están escritas para Posix, de modo que si read() o write() son interrumpidas por una señal las llama nuevamente. En Linux normal van a funcionar igual, salvo que ese caso no va a ocurrir.
